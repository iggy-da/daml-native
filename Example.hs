{-# LANGUAGE DamlSyntax #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}

module Main where

{-
This file contains an example of a DAML template which can be compiled, desugared, and type-check:
$ ./_build/stage1/bin/ghc ./Example.hs

A minimal environment (to support the code generated by desugaring) is provided in:
  ./DA/Internal/Desugar.hs
  ./GHC/Types.hs
-}

import DA.Internal.Desugar
import GHC.Types
import Control.Monad.Trans.Except
import Control.Exception
import Control.Monad.IO.Class


main = runExceptT run

run =
  do
    putLns
      [ "My TheTemplate has the message:"
      , message mytemplate
      ]
    putLns
      [ "The signatories on my TheTemplate are"
      , show $ signatory mytemplate
      ]
    putLns
      [ "TheTemplate.MyObservedChoice is a"
      , show $ consuming @TheTemplate @MyObservedChoice 
      , "choice"
      ]
    result <- (applyChoice cid mytemplate mychoice) -- execute choice body code
    putLns
      [ "The choice returned: "
      , show (result : Int)
      ]
    pure ()


template TheTemplate
  with
    s1 : Party
    s2 : Party
    message : String
    number : Int
  where
    signatory s1
    signatory s2
    agreement "my agreement"

    nonconsuming choice MyObservedChoice : Int with obs : [Party]; other : Int
      observer obs
      controller s1
      do 
        putLns
          [ "Executing MyObservedChoice"
          , "..."
          , "It executed!"]
        return (number + other)


putLns = liftIO . putStrLn . unwords

party1 = Party "Bob"
party2 = Party "Alice"
party3 = Party "Iggy"
party4 = Party "Johndoe"

mytemplate = TheTemplate party1 party2 "'This runs on machine code.'" 40

mychoice = MyObservedChoice with obs = []; other = 2
cid : ContractId TheTemplate
cid = ContractId


